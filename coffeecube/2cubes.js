// Generated by CoffeeScript 1.6.1
(function() {
  var animate, common, init, ntex, render, scalefactor, shrinkTexture, stats, wiggleCube;

  common = {};

  common.startTime = performance.now();

  stats = new Stats();

  scalefactor = 0.9;

  ntex = 20;

  shrinkTexture = function(tex, scale, tn) {
    var canvas, ctx, dim, fun, im, newHeight, newWidth, _ref;
    im = tex.image;
    _ref = (function() {
      var _i, _len, _ref, _results;
      _ref = [im.width, im.height];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dim = _ref[_i];
        _results.push(Math.floor(dim * scale));
      }
      return _results;
    })(), newWidth = _ref[0], newHeight = _ref[1];
    canvas = document.createElement('canvas');
    canvas.width = newWidth;
    canvas.height = newHeight;
    ctx = canvas.getContext("2d");
    ctx.drawImage(im, 0, 0, im.width, im.height, 0, 0, newWidth, newHeight);
    tex.image = canvas;
    tex.needsUpdate = 1;
    fun = function() {
      return shrinkTexture(tex, scale);
    };
    return console.log("scaled", tn, "to", tex.image.width, "x", tex.image.height);
  };

  init = function() {
    var camera, container, i, makeCube, renderer, textures, _i, _ref;
    if (!Detector.webgl) {
      Detector.addGetWebGLMessage();
    }
    common.camera = camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.y = 150;
    camera.position.z = 350;
    common.scene = new THREE.Scene();
    textures = {};
    makeCube = function(i) {
      var cube;
      textures[i] = THREE.ImageUtils.loadTexture("big_tex_" + i + ".png", void 0, function() {
        return shrinkTexture(textures[i], scalefactor, i);
      });
      cube = new THREE.Mesh(new THREE.CubeGeometry(200, 200, 200), new THREE.MeshBasicMaterial({
        map: textures[i],
        transparent: true,
        opacity: 0.5
      }));
      cube.position.y = 100 + i * 20;
      common.scene.add(cube);
      return cube;
    };
    common.cubes = [];
    for (i = _i = 0, _ref = ntex - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      common.cubes.push(makeCube(i));
    }
    container = common.container = document.createElement('div');
    document.body.appendChild(container);
    common.renderer = renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    common.stats = stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '0px';
    return container.appendChild(stats.domElement);
  };

  animate = function() {
    render();
    requestAnimationFrame(animate);
    return stats.update();
  };

  wiggleCube = function(cube, dtime) {
    cube.rotation.x += 0.02;
    cube.rotation.y += 0.0225;
    cube.rotation.z += 0.0175;
    return cube.scale.y = cube.scale.z = cube.scale.x = 1.0 + .3 * Math.sin(dtime / 300);
  };

  render = function() {
    var c, dtime, offset, _i, _len, _ref;
    dtime = Date.now() - common.startTime;
    offset = 0;
    _ref = common.cubes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      wiggleCube(c, dtime + 10 * offset++);
    }
    return common.renderer.render(common.scene, common.camera);
  };

  init();

  animate();

}).call(this);
